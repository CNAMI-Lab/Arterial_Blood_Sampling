import os
import pandas as pd
import numpy as np
import statistics
import xlrd
import matplotlib.pyplot as plt


class FreeFraction:
    def __init__(self, halflife, bkg, tubes, tube_results, sample_values, sample_positions, final_results,
                 file_path):

        self.halflife = halflife
        self.bkg = bkg
        self.tubes = tubes
        self.tube_results = tube_results
        self.sample_values = sample_values
        self.sample_positions = sample_positions
        self.final_results = final_results
        self.file_path = file_path

    def parse_values(self, file_path, sample_positions):  # WORKS
        df = pd.read_excel(file_path, skiprows=20)

        sample_values = {}

        for tube, positions in sample_positions.items():
            print(f"Tube: {tube}")
            tube_sample_values = {}
            for position in positions:
                print(f"Position: {position}")
                current_row = df[(df['POS'] == position) & (df['CH'] == 1)]
                next_row_empty = df['POS'].shift(-1).loc[current_row.index].isna().item()

                cpm1 = current_row['CPM'].values[0] if not current_row.empty else None
                eltime = current_row['ELTIME  '].values[0] if not current_row.empty else None
                # may need to change spaces for next study

                if next_row_empty:
                    next_row_cpm2 = df['CPM'].shift(-1).loc[current_row.index].dropna()
                    if not next_row_cpm2.empty:
                        cpm2 = next_row_cpm2.values[0]

                tube_sample_values[position] = {
                    'CPM1': cpm1,
                    'CPM2': cpm2,
                    'ELTIME': eltime
                }

            sample_values[tube] = tube_sample_values

        return sample_values

    sample_values = parse_values(file_path, sample_positions)

    def columnf_calc(self):  # WORKS
        tube_results = {}
        file_path = 'FF Calculator 2022 v2 EJ.xls'
        sample_positions = {
            'A': [14, 15, 16],
            'B': [18, 19, 20],
            'C': [22, 23, 24],
            'D': [26, 27, 28],
            'E': [30, 31, 32],
            'F': [34, 35, 36]
        }
        parsed_values = parse_values(file_path, sample_positions)
        self.halflife = 20.34
        self.bkg = 28

        for tube, tube_sample_values in parsed_values.items():
            tube_results[tube] = {}
            for position, values in tube_sample_values.items():  # this is probably the issue
                cpm1 = values['CPM1']
                cpm2 = values['CPM2']
                eltime = values['ELTIME']

                calculation = (cpm1 + cpm2 - self.bkg) * 2 ** eltime / self.halflife  # calc is off
                tube_results[tube][position] = calculation

        return tube_results

    def ff_calc(self):
        final_results = {}

        for tube, positions in sample_positions.items():
            tube_results = columnf_calc()[tube]

            calculation_values = []
            for position in positions:
                if position in tube_results:
                    calculation_values.append(tube_results[position])
                else:
                    calculation_values.append(0)  # If position is missing, assume value of 0

            c_aliquot, c_remainder, c_top = calculation_values
            print("Tube:", tube, "Aliquot:", c_aliquot, "Remainder:", c_remainder, "Top:", c_top)

            if tube == list(sample_positions.keys())[0]:
                final_calculation = result = (c_aliquot / 0.15) / ((c_aliquot + c_remainder + c_top) / 0.5)

            else:
                final_calculation = result = (c_aliquot / 0.15) / ((c_aliquot + c_remainder + c_top) / 0.4)

            final_results[tube] = final_calculation

        return final_results

    final_results = ff_calc(self)

    def stats(self):
        final_results = ff_calc()
        results_values = list(final_results.values())[:4]
        saline = list(final_results.values())[-2:]

        average = statistics.mean(results_values)
        std_dev = statistics.stdev(results_values)
        saline_average = statistics.mean(saline)
        saline_std = statistics.stdev(saline)

        print("Average:", average, "Standard Deviation:", std_dev, "Saline Average: ", saline_average, "Saline StDev: ",
              saline_std)

        return average, std_dev, saline_average, saline_std

    def create_boxplot(self):
        final_results = {'A': 0.3357582116707509,
                         'B': 0.28148167731241813,
                         'C': 0.29550856039431306,
                         'D': 0.3099990954690565,
                         'E': 0.8778051288501841,
                         'F': 0.8837126248542743}

        # final_results = ff_calc(self)

        x_values = ['A', 'B', 'C', 'D', 'E', 'F']
        y_values = [final_results[key] for key in x_values]
        print(y_values)

        # data = [0.3357582116707509, 0.28148167731241813, 0.29550856039431306, 0.3099990954690565, 0.8778051288501841, 0.8837126248542743]

        fig, ax = plt.subplots()

        ax.boxplot(y_values)

        ax.set_xticks(range(1, len(x_values) + 1))
        ax.set_xticklabels(x_values)

        ax.set_xlabel('Tube')
        ax.set_ylabel('Free Fraction')
        ax.set_title('Box Plot of Final Results')

        plt.text(0.95, 0.95,
                 f'Average: {average:.2f}\nStd Dev: {std_dev:.2f}\nSaline Average: {saline_average:.2f}\nSaline Std: {saline_std:.2f}',
                 transform=ax.transAxes, fontsize=10, va='top', ha='right',
                 bbox=dict(facecolor='white', edgecolor='gray', boxstyle='round'))

        plt.show()


# #instance variables for MDL
# self.halflife = 20.34
# self.bkg = 28
# self.tubes = ['A', 'B', 'C', 'D', 'E', 'F']
# self.sample_values = sample_values
# self.tube_results = tube_results
# self.sample_positions = {
#     'A': [14, 15, 16],
#     'B': [18, 19, 20],
#     'C': [22, 23, 24],
#     'D': [26, 27, 28],
#     'E': [30, 31, 32],
#     'F': [34, 35, 36]
# }
# self.final_results = final_results
# self.file_path = 'FF Calculator 2022 v2 EJ.xls'


# instance variables for 20221019_18FASEM

self.halflife = 109.7
self.bkg = 28
self.tubes = ['A', 'B', 'C', 'D', 'E', 'F']
self.sample_values = sample_values
self.tube_results = tube_results
self.sample_positions = {
    'A': [109, 110, 111],
    'B': [113, 114, 115],
    'C': [117, 118, 119],
    'D': [121, 122, 123],
    'E': [125, 126, 127],
    'F': [129, 130, 131]
}

self.file_path = '20221019_18FASEM.xlsx'
self.final_results = final_results

ff = FreeFraction(halflife, bkg, tubes, tube_results, sample_values, sample_positions, final_results,
                 file_path)
ff.run()



##unit tests below

import unittest
from freefractioncalc import FreeFraction


class TestParsing(unittest.TestCase):
    def test_parse_values(self):
        file_path = 'FF Calculator 2022 v2 EJ.xls'
        sample_positions = {
            'A': [14, 15, 16],
            'B': [18, 19, 20],
            'C': [22, 23, 24],
            'D': [26, 27, 28],
            'E': [30, 31, 32],
            'F': [34, 35, 36]
        }

        expected_values = {
            'A': [
                {'CPM1': 22914, 'CPM2': 7819, 'ELTIME': 2.94},
                {'CPM1': 12162, 'CPM2': 4073, 'ELTIME': 4.24},
                {'CPM1': 178175, 'CPM2': 64150, 'ELTIME': 4.69}
            ],
            'B': [
                {'CPM1': 16391, 'CPM2': 5540, 'ELTIME': 7.28},
                {'CPM1': 4229, 'CPM2': 1402, 'ELTIME': 8.58},
                {'CPM1': 123930, 'CPM2': 45030, 'ELTIME': 9.1}
            ],
            'C': [
                {'CPM1': 15093, 'CPM2': 5119, 'ELTIME': 11.69},
                {'CPM1': 5726, 'CPM2': 1707, 'ELTIME': 12.99},
                {'CPM1': 106648, 'CPM2': 37533, 'ELTIME': 13.67}
            ],
        }

        free_fraction = FreeFraction(halflife=20.34, bkg=28.0)
        sample_values = free_fraction.parse_values(file_path)

        for tube, positions in sample_positions.items():
            for position, sample_values in zip(positions, sample_values[tube]):
                self.assertEqual(sample_values['CPM1'], expected_values[tube][position]['CPM1'])
                self.assertEqual(sample_values['CPM2'], expected_values[tube][position]['CPM2'])
                self.assertEqual(sample_values['ELTIME'], expected_values[tube][position]['ELTIME'])
                # Add more assertions as needed for other sample values

if __name__ == '__main__':
    unittest.main()

import unittest
from freefractioncalc import FreeFraction


class TestFFCalc(unittest.TestCase):
    def setUp(self):
        self.halflife = 20.34
        self.bkg = 28
        self.tubes = ['A', 'B', 'C']
        self.samples = ['aliquot', 'remainder', 'top']

    def test_ff_calc(self):
        sample_values = {
            'aliquot': {'A': {'CPM1': 22914, 'CPM2': 7819, 'ELTIME': 2.94},
                        'B': {'CPM1': 16391, 'CPM2': 5540, 'ELTIME': 7.28},
                        'C': {'CPM1': 15093, 'CPM2': 5119, 'ELTIME': 11.69}},
            'remainder': {'A': {'CPM1': 12162, 'CPM2': 4073, 'ELTIME': 4.24},
                          'B': {'CPM1': 4229, 'CPM2': 1402, 'ELTIME': 8.58},
                          'C': {'CPM1': 4229, 'CPM2': 1402, 'ELTIME': 8.58}},
            'top': {'A': {'CPM1': 178175, 'CPM2': 64150, 'ELTIME': 4.69},
                    'B': {'CPM1': 123930, 'CPM2': 45030, 'ELTIME': 9.1},
                    'C': {'CPM1': 106648, 'CPM2': 37533, 'ELTIME': 13.67}}
        }
        free_fraction = FreeFraction(self.halflife, self.bkg, self.tubes, self.samples)
        final_results = free_fraction.ff_calc(sample_values)

        expected_results = {
            'A': (sample_values['aliquot']['A']['CPM1'] / 0.15) / (
                    sample_values['aliquot']['A']['CPM1'] + sample_values['remainder']['A']['CPM1'] +
                    sample_values['top']['A']['CPM1']) / 0.5,
            'B': (sample_values['aliquot']['B']['CPM1'] / 0.15) / (
                    sample_values['aliquot']['B']['CPM1'] + sample_values['remainder']['B']['CPM1'] +
                    sample_values['top']['B']['CPM1']) / 0.4,
            'C': (sample_values['aliquot']['C']['CPM1'] / 0.15) / (
                    sample_values['aliquot']['C']['CPM1'] + sample_values['remainder']['C']['CPM1'] +
                    sample_values['top']['C']['CPM1']) / 0.4
        }

        self.assertEqual(final_results, expected_results)


import unittest
import statistics


def calculate_average_std(final_results):
    results_values = list(final_results.values())
    saline = results_values[-2:]

    average = statistics.mean(results_values)
    std_dev = statistics.stdev(results_values)
    saline_average = statistics.mean(saline)
    saline_std = statistics.stdev(saline)

    return average, std_dev, saline_average, saline_std


class TestCalculateAverageStd(unittest.TestCase):
    def test_calculate_average_std(self):
        final_results = {'A': 0.336, 'B': 0.281, 'C': 0.296, 'D': 0.310, 'E': 0.878, 'F': 0.884}
        expected_average = 0.306
        expected_std_dev = 0.02
        expected_saline_average = .881
        expected_saline_std = 0.003

        actual_average, actual_std_dev, actual_saline_average, actual_saline_std = calculate_average_std(final_results)

        self.assertEqual(actual_average, expected_average)
        self.assertAlmostEqual(actual_std_dev, expected_std_dev, places=8)
        self.assertEqual(actual_saline_average, expected_saline_average)
        self.assertAlmostEqual(actual_saline_std, expected_saline_std, places=8)


if __name__ == '__main__':
    unittest.main()



    

